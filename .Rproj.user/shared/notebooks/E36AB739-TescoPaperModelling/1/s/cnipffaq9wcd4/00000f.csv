"0","# Yeo Johnson transform"
"0","yeo_johnson <- function(x, lambda) {"
"0","  eps <- .000001"
"0","  not_neg <- which(x >= 0)"
"0","  is_neg  <- which(x < 0)"
"0","  not_neg_trans <- function(x, lambda) {"
"0","    if (abs(lambda) < eps) log(x + 1)"
"0","    else ((x + 1) ^ lambda - 1) / lambda"
"0","  }"
"0","  neg_trans <- function(x, lambda) {"
"0","    if (abs(lambda - 2) < eps) - log(-x + 1)"
"0","    else - ((-x + 1) ^ (2 - lambda) - 1) / (2 - lambda)"
"0","  }"
"0","  x[not_neg] <- not_neg_trans(x[not_neg], lambda)"
"0","  x[is_neg] <- neg_trans(x[is_neg], lambda)"
"0","  return(x)"
"0","}"
"0",""
"0","# New model data variable - GWR model data"
"0","# Takes the old model_data variable and transforms PC1 according to YJ (using optimal lambda)"
"0","model_data$PC1_yj <- yeo_johnson(model_data$PC1, lambda = lambda_yj) "
"0","model_data$geometry <- london_data$geometry"
"0",""
"0","# Let's define a new PC1_yj2 which subtracts the intercept term from the previous backward selection model: "
"0","model_data$PC1_yj2 <- model_data$PC1_yj + 0.1458"
"0",""
"0","# Let's also scale the explanatory variables"
"0","scaled_data <- na.omit(st_as_sf(model_data)) %>% dplyr::mutate(across(avg_age:BAME_2011_perc, scale))"
"0","                                                    "
